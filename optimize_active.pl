%% #!/opt/local/bin/swipl -q -g main -f
%% uncomment first line to make an SWI executable

/*
Copyright (C) Peter Ljunglöf

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.
*/

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Conversion script for the Active MCFG parser
%% By Peter Ljunglöf (Time-stamp: "2005-12-09, 14:45")
%%
%% initial MCFG rule format:
%%
%%   rule(Profile, Cat, f(Cat1,...,CatN), [Lbl=Lin | Lins]),
%%
%% the rules are converted to MCFG rule formats for this parser:
%%
%% if Lin = []:
%%   eps_rule(Lbl, Lins, AbsRule)
%%
%% if Lin = [tok(Word) | Symbols]:
%%   tok_rule(Word, Lbl, Symbols, Lins, AbsRule)
%%
%% if Lin = [arg(Cat,Nr,PLbl) | Symbols):
%%   cat_rule(Cat, PLbl, Nr, Lbl, Symbols, Lins, AbsRule)
%%
%% where AbsRule = rule(Profile, Cat, f(Cat1,...,CatN))
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

:- use_module(library(lists), [member/2, append/3]).
:- use_module(mcfg, [language/1, expand_variants/2]).

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% main predicate, call from unix:
%% 
%% > swipl -q -g main -f optimize_active.pl -- grammar.pl (startsymbols.pl) > optimized_grammar.pl
%% > sicstus -f --goal 'main.' -l optimize_active.pl -a -- grammar.pl (startsymbols.pl) > optimized_grammar.pl
%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

main :-
	current_prolog_flag(argv, Argv),
	Files = [_|_],
	append(_, [-- | Files], Argv),
	!,
	\+ (
	     member(File, Files),
	     format(user_error, '\n--- Consulting file: ~w\n', [File]),
	     consult(File),
	     fail
	   ),
	grammar_header,
	write(user_error, '\n--- Filtering grammar by starting categories\n'),
	filter_grammar,
	write(user_error, '\n--- Writing optimized clauses\n\n'),
	convert_all,
	halt.
main :-
	nl(user_error),
	write(user_error, 'Usage,    SWI: swipl -q -t main -s optimize_active.pl -- ARGUMENTS\n'), 
	write(user_error, '      SICStus: sicstus -f --goal \'main.\' -l optimize_active.pl -a -- ARGUMENTS\n\n'),
	write(user_error, 'where ARGUMENTS = grammar.pl (startsymbols.pl) > optimized_grammar.pl\n\n'),
	halt(1).


grammar_header :-
	write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'), nl,
	write('%% Autogenerated multilingual MCFG grammar'), nl, 
	write('%% Optimized for parsing with the Active bottomup algorithm'), nl,
	write('%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%'), nl, nl.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% top-down filtering of the grammar
%% if Module:startsymbol/1 is undefined, then there will be no filtering

:- dynamic filtered_cat/2.

filter_grammar :-
	retractall(filtered_cat(_,_)),
	\+ (
	     language(Module),
	     format(user_error, '  >> Language module: ~w\n', [Module]),
	     filter_module(Module),
	     fail
	   ).

filter_module(Module) :-
	format('%% Start symbols for language module: ~q\n\n', [Module]),
	( Module:current_predicate(startsymbol/1) ->
	    \+ (
		 Module:startsymbol(Start),
		 format(user_error, '     Start symbol: ~w\n', [Start]),
		 ( Module = user ->
		     format('~q.\n', [startsymbol(Start)])
		 ;
		     format('~q : ~q.\n', [Module, startsymbol(Start)])
		 ),
		 filter_cat(Start, Module),
		 fail
	       )
	;
	    write('%% No start symbols defined'), nl,
	    format(user_error, '     No start symbols defined\n', []),
	    assert(filtered_cat(_, Module))
	), nl.

filter_cat(Cat, Module) :-
	\+ filtered_cat(Cat, Module),
	%% format(user_error, 'FILTER: ~q\n', [Cat]),
	assert(filtered_cat(Cat, Module)),
	\+ (
	     Module : rule(_, Cat, Cats0, _),
	     Cats0 =.. [_|Cats],
	     member(Dtr, Cats),
	     filter_cat(Dtr, Module),
	     fail
	   ).
	
	
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% converting each module in turn

convert_all :-
	\+ (
	     language(Module),
	     format(user_error, '  >> Language module: ~w\n', [Module]),
	     format('%% Optimized clauses for language module: ~q\n\n', [Module]),
	     ( Module = user ->
		 format(':- discontiguous ~q, ~q, ~q.\n\n', [eps_rule/3, tok_rule/5, cat_rule/7])
	     ;
		 format(':- discontiguous ~q, ~q, ~q.\n\n', [Module:eps_rule/3, Module:tok_rule/5, Module:cat_rule/7])
	     ),
	     convert_module_rule(Module, Rule),
	     ( Module = user ->
		 format('~q.\n', [Rule])
	     ;
		 format('~q : ~q.\n', [Module, Rule])
	     ),
	     fail
	   ).

convert_module_rule(Module, NewRule) :-
	Module : rule(Profile, Cat, Args, Lins0),
	filtered_cat(Cat, Module),
	expand_variants(Lins0, Lins),
	convert_rule(Profile, Cat, Args, Lins, NewRule).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% the real rule optimization:

convert_rule(FunProfs, Cat, Cats, [Lbl = Symbols | Lins], NewRule) :-
	FunProfs =.. [Fun | Profs],
	( number_sequence(Profs, 1) ->
	    AbsRule = rule(Fun, Cat, Cats)
	;
	    AbsRule = rule(FunProfs, Cat, Cats)
	),
	convert_rule2(Symbols, Lbl, Lins, AbsRule, NewRule).

convert_rule2([Sym | Symbols], Lbl, Lins, AbsRule, NewRule) :-
	convert_rule3(Sym, Lbl, Symbols, Lins, AbsRule, NewRule).
convert_rule2([], Lbl, Lins, AbsRule,
	      eps_rule(Lbl, Lins, AbsRule)).

convert_rule3(tok(Word), Lbl, Symbols, Lins, AbsRule,
	      tok_rule(Word, Lbl, Symbols, Lins, AbsRule)).
convert_rule3(arg(Cat,Nr,PLbl), Lbl, Symbols, Lins, AbsRule,
	      cat_rule(Cat, PLbl, Nr, Lbl, Symbols, Lins, AbsRule)).


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% utils

number_sequence([], _).
number_sequence([N | Ns], N) :-
	N1 is N+1,
	number_sequence(Ns, N1).
